2.5 定点运算器的组成
2.5.1 逻辑运算 2.5.2 多功能算术逻辑运算单元 2.5.3 内部总线 2.5.4 定点运算器的基本结构

2.5.1 逻辑运算 计算机中除了进行加、减、乘、除等基本算术运算外,还 可对两个或一个逻辑数进行逻辑运算。 所谓逻辑数,是指不带符号的二进制数。利用逻辑运算可 以行两个数的比较,或者从某个数中选取某几位等操作。 计算机中的逻辑运算,主要是指逻辑非、逻辑加、逻辑乘、 逻辑异四种基本运算。

1.逻辑非运算 逻辑非也称求反。对某数进行逻辑非运算,就是按位求它的 反,常用变量上方加一横来表示。 设一个数ｘ表示成： ｘ＝ｘ0ｘ1ｘ2…ｘn 对ｘ求逻辑非,则有 ｘ＝ｚ＝ｚ0ｚ1ｚ2…ｚn ｚi＝ｘi, (i＝0,1,2,…n) [例21] ｘ1＝01001011,ｘ2＝11110000,求ｘ1 ， ｘ2 [解:] ｘ1＝10110100 ｘ2＝00001111

2.逻辑加运算

和0加不变，和1加为1,常用于置1操作

对两个数进行逻辑加,就是按位求它们的“或”,所以逻辑加 又称逻辑或,常用记号“V”或“＋”来表示。 设有两数 ,它们表示为 ｘ＝ｘ0ｘ1…ｘn ｙ＝ｙ0ｙ1…ｙn 若 ｘ∨ｙ＝ ｚ ＝ ｚ0 ｚ1 ｚ2 …ｚn 则 ｚ i＝ ｘ i∨ ｙ i, (i＝0,1,2,…,n) [例22] ｘ＝10100001,将第5、6位置1，其余位不变。 [解:] 10100001ｘ ∨ 00001100 10101101 即 .

ｘ∨ｙ ＝ 1 0 1 0 1 1 0 1

3.逻辑乘运算

和0乘置0，和1乘不变，常用于置0操作

对两数进行逻辑乘,就是按位求它们的“与”,所以逻辑乘又 称“逻辑与”,常用记号“∧”或“・”来表示。 设有两数ｘ和ｙ,它们表示为 ｘ＝ｘ0ｘ1…ｘn ｙ＝ｙ0ｙ1…ｙn 若 ｘ∧ｙ＝ ｚ ＝ ｚ0 ｚ1 ｚ2 …ｚ n 则 ｚ i＝ ｘ i ∧ ｙ i, (i＝0,1,2,…,n) [例23] ｘ＝10111001,将第5、6位置0，其余位不变。 [解:] 10111001ｘ ∧ 11110011ｙ 10110001ｚ

4.逻辑异运算

和0异或不变，和1异或取反，常用于取反操作

对两数进行异就是按位求它们的模2和,所以逻辑异又称“按 位加”,常用记号“”表示。 设有两数ｘ和ｙ： ｘ＝ｘ0ｘ1…ｘn ｙ＝ｙ0ｙ1…ｙn 若ｘ和ｙ的逻辑异为ｚ： ｘｙ＝ｚ＝ｚ0ｚ1ｚ2…ｚn 则 ｚ i＝ ｘ i ｙ i, (i＝0,1,2,…,n) [例24] ｘ＝10101011,将第5、6位取反，其余位不变。 [解:] 10101011ｘ  00001100ｙ 10100111ｚ

2.5.2 多功能算术/逻辑运算单元(ALU) 由一位全加器(FA)构成的行波进位加法器,可以实现补码数 的加法运算和减法运算。 两个问题： 一:串行进位,运算时间很长。 假如加法器由n位全加器构成,每一位的进位延迟时间为20ns, 最坏情况下, 进位信号从最低位传递到最高位而最后输出稳定,至 少需要n×20ns。 二:只能完成加法和减法两种操作而不能完成逻辑操作。 多功能算术/逻辑运算单元(ALU) 不仅具有算术运算和逻辑运算的功能,而且具有先行进位逻 辑, 能实现高速运算。

1.基本思想 一位全加器(FA)的逻辑表达式为 Fi＝AiBiCi Ci＋1＝AiBi＋BiCi＋CiAi (2.35)

将Ai和Bi先组合成由控制参数S0、S1、S2、S3控制的组 合函数Xi和Yi，然后再将Xi、Yi和下一位进位数通过全加器进 行全加。 不同的控制参数可以得到不同的组合函数，实现多种算术 运算和逻辑运算。

Fi＝AiBiCi Ci＋1＝AiBi＋BiCi＋CiAi

Fi=XiYiCi Ci+1=XiYi+YiCi+CiXi

一位算术/逻辑运算单元的逻辑表达式为 Fi=XiYiCn+i Cn+i+1=XiYi+YiCn+i+Cn+iXi

Fi=XiYiCn+i Cn+i+1=XiYi+YiCn+i+Cn+iXi 上式中进位下标用n＋i代替原来以为全加器中的i,i代表集 成在一片电路上的ALU的二进制位数。 对于4位一片的ALU,i＝0,1,2,3。n代表若干片ALU组成更大 字长的运算器时每片电路的进位输入,例如当4片组成16位字长的 运算器时,n＝0,4,8,12。 2.逻辑表达式 控制参数S0 ,S1 ,S2 ,S3 分别控制输入Ai 和Bi ,产生Y和X的函数。 其中Yi是受S0 ,S1控制的Ai和Bi的组合函数,而Xi是受S2 ,S3控制的 Ai和Bi组合函数,其函数关系如下表所示。

S0 S1 0 0 1 1

Yi

S2 S3 0 0 1 1

Xi

0 Ai 1 AiBi 0 AiBi 0 1

1 0 1 Ai＋Bi 0 Ai＋Bi Ai 1

根据上面所列的函数关系,即可列出Xi和Yi的逻辑表达式 Xi＝S2S3＋S2S3（Ai＋Bi）＋S2S3（Ai＋Bi）＋S2S3Ai Yi＝S0S1Ai＋S0S1AiBi＋S0S1AiBi 进一步化简并代入前面的求和与进位表达式，可得ALU的某一 位逻辑表达式如下

Fi＝YiXiCn+i Cn＋i＋1＝Yi＋XiCn＋i

(2.36)

4位之间采用先行进位公式,根据式（2.36）,每一位的进位公 式可递推如下： 第0位向第1位的进位公式为 Cn＋1＝Y0＋X0Cn 其中Cn是向第0位（末位）的进位。 第1位向第2位的进位公式为 Cn＋2＝Y1＋X1Cn＋1＝Y1＋Y0X1＋X0X1Cn 第2位向第3位的进位公式为 Cn＋3＝Y2＋X2Cn＋2＝Y2＋Y1X2＋Y0X1X2＋X0X1X2Cn 第3位的进位输出（即整个4位运算进位输出）公式为 Cn＋4＝Y3＋X3Cn＋3 ＝Y3＋Y2X3＋Y1X2X3＋Y0X1X2X3＋X0X1X2X3Cn 设 G＝Y3＋Y2X3＋Y1X2X3＋Y0X1X2X3 P＝X0X1X2X3 则 Cn＋4＝G＋PCn (2.37)

Cn+4

Cn

Cn+3

Cn+2

Cn+1

Cn+4是本片(组)的最后进位输出。 逻辑表达式表明,这是一个先行进位逻辑。 第0位的进位输入Cn可以直接传送到最高位上去,因而可以实现 高速运算。 对一片ALU来说,可有三个进位输出。其中G称为进位发生 输出,P称为进位传送输出。 在电路中多加这两个进位输出的目的,是为了便于实现多 片（组）ALU之间的先行进位,为此还需一个配合电路,称之为 先行进位发生器(CLA),下面还要介绍。

用正逻辑表示的4位算术/逻辑运算单元(ALU)的逻辑电路图演示 ,它是根据 上面的原始推导公式用TTL电路实现的。这个器件的商业标号为74181ALU

1
0 1 1 0 0 1 0 1 0 0 0 0 0 0 1 0

1

1

0

1 0 0

0 1

0 0

1 0 0

0 C=1 0

1

0

1

1

0

0

0 1

1 0

1

0

1

0

0

0

1

1

3.算术逻辑运算的实现 除了S0－S3四个控制端外,还有一个控制端Ｍ用来控制ALU是 进行算术运算还是逻辑运算。 当Ｍ＝0时,Ｍ对进位信号没有任何影响。F 不仅与本位的操 作数Y和X 有关,而且与本位的进位输出,即C 有关,因此Ｍ＝0时,进 行算术操作。 当Ｍ＝1时,封锁了各位的进位输出,即C ＝0,因此各位的运算 结果F 仅与Y 和X 有关,故Ｍ＝1时,进行逻辑操作。 器件74181ALU执行的正逻辑输入/输出方式的一组算术运算 和逻辑操作与负逻辑输入/输出方式的一组算术运算和逻辑操作是 等效的。

图2.11

74181ALU的逻辑电路图和方框图

对正逻辑操作数来说,算术运算称高电平操作,逻辑运算称正 逻辑操作(即高电平为“1”,低电平为“0”)。 对于负逻辑操作数来说,正好相反。 由于S －S 有16种状态组合,因此对正逻辑输入与输出而言, 有16种算术运算功能和16种逻辑运算功能。 同样,对于负逻辑输入与输出而言,也有16种算术运算功能 和16种逻辑运算功能。

说明：(1)H＝高电平,L＝低电平.(2)*表示每一位均移到下 一个更高位,即A*＝2A 注意,表2.5中算术运算操作是用补码表示法来表示的。 其中“加”是指算术加,运算时要考虑进位,而符号“＋” 是指“逻辑加”。 其次,减法是用补码方法进行的,其中数的反码是内部产生 的,而结果输出“A减B减1”,因此做减法时需在最末位产生一个 强迫进位(加1),以便产生“A减B”的结果。 另外,“A＝B”输出端可指示两个数相等,因此它与其他ALU 的“A＝B"输出端按“与”逻辑连接后,可以检测两个数的相等 条件。

4.两级先行进位的ALU 74181ALU设置了P和G两个本组先行进位输出端。如果将四片 74181的P,G输出端送入到74182先行进位部件（CLA）,又可实现第 二级的先行进位,即组与组之间的先行进位。 假设4片（组）74181的先行进位输出依次为 P0,G0,G1P1,P2,G2,P3,G3,那么参考式(2.37)的进位逻辑表达式,先 行进位部件74182CLA所提供的进位逻辑关系如下： Cn＋ｘ＝G0＋P0Cn Cn＋ｙ＝G1＋P1Cn＋ｘ＝G1＋G0P1＋P0P1Cn Cn＋ｚ＝G2＋P2Cn＋ｙ＝G2＋G1P2＋G0P1P2＋P0P1P2Cn (2.38) Cn＋4 ＝G3＋P3Cn＋ｚ ＝G3＋G2P3＋G1P1P2＋G0P1P2P3＋P0P1P2P3Cn ＝G*＋P*Cn 其中 P*＝P0P1P2P3 G*＝G3＋G2P3＋G1P1P2＋G0P1P2P3

根据以上表达式,用TTL器件实现的成组先行进位部件74182 的逻辑电路图如所示 其中G*称为成组进位发生输出,P*称为成 组进位传送输出。 用若干个74181ALU位片,与配套的74182先行进位部件CLA 在一起,构成一个全字长的ALU。 下图示出了用两个16位全先行进位部件级联组成的32位ALU 逻辑方框图。在这个电路中使用了八个74181ALU和两个74182CLA 器件。 很显然,对一个16位来说,CLA部件构成了第二级的先行进位 逻辑,即实现四个小组（位片）之间的先行进位,从而使全字长 ALU的运算时间大大缩短。

。

两级先行进位部件级联组成的32位ALU

2.5.3 内部总线
机器内部各部件之间的数据传送非常频繁。 为了减少内部的传送线并便于控制,将数据传送的通路加以归 并,组成总线结构,使不同来源的信息在此传输线上分时传送。 根据总线所在位置,总线分为内部总线和外部总线两类。内部 总线是指CPU内各部件的连线,而外部总线是指系统总线,即CPU与 存储器、I/O系统之间的连线。本节只讨论内部总线。 按总线的逻辑结构来说,总线可分为单向总线和双向总线。 单向总线：信息只能向一个方向传送。 双向总线：信息可以分两个方向传送,既可以发送数据,也可以 接收数据

带有缓冲驱动器的4位双向数据总线。其中所用的基本电路 就是三态逻辑电路。 当“发送”信号有效时,数据从左向右传送。反之,当“接收 ”信号有效时,数据从右向左传送。 这种类型的缓冲器通常根据它们如何使用而叫作总线扩展 器、总线驱动器、总线接收器等等。

2.5.4 定点运算器的基本结构
运算器包括ALU\阵列乘除器\寄存器\多路开关\三态缓冲 器\数据总线等逻辑部件。 运算器的设计,主要是围绕ALU和寄存器同数据总线之间 如何传送操作数和运算结果进行的。 在决定方案时,需要考虑数据传送的方便性和操作速度,在 微型机和单片机中还要考虑在硅片 上制作总线的工艺。 计算机的运算器大体有如下三种结构形式 单总线、双总线、三总线

1.单总线结构的运算器

由于所有部件都接到同一总线上,所以数据可以在任何两个寄存 器之间,或者在任一个寄存器和ALU之间传送。 在同一时间内,只能有一个操作数放在单总线上。 为了把两个操作数输入到ALU,需要分两次来做,而且还需要A,B 两个缓冲寄存器。 这种结构的主要缺点是操作速度较慢。 由于它只控制一条总线,故控制电路比较简单。

2.双总线结构的运算器

两条总线各自把其数据送至ALU的输入端。 ALU的输出不能直接加到总线上去。 因为当形成操作结果的输出时,两条总线都被输入数占据,因而 必须在ALU输出端设置缓冲寄存器。为此,操作的控制要分两步: 1.在ALU的两个输入端输入操作数,形成结果并送入缓冲寄存 器; 2.把结果送入目的寄存器。假如在总线1,2和ALU输入端之间 再各加一个输入缓冲寄存器,并把两个输入数先放至这两个缓冲寄 存器,那么,ALU输出端就可以直接把操作结果送至总线1或总线2上 去。

3.三总线结构的运算器 三总线结构中,ALU的两个输入端分别由两条总线供给,而 ALU的输出则与第三条总线相连。这样,算术逻辑操作就可以在 一步的控制之内完成。 由于ALU本身有时间延迟,所以打入输出结果的选通脉冲必 须考虑到包括这个延迟。另外,设置了一个总线旁路器。如果一 个操作数不需要修改,而直接从总线2传送到总线3,那么可以通过 控制总线旁路器把数据传出;如果一个操作数传送时需要修改,那 么就借助于ALU。 很显然,三总线结构的运算器的特点是操作时间快。

2.浮点数的表示方法
科学计数法 电子的质量＝9×10－28克=0.000000……0000009克 太阳的质量＝2×1033克 =200000000……000000000克 二者相差甚远。 定点计算机无法直接表示这个数值范围。要使它们送入定点 计算机进行某种运算，必须对它们分别取不同的比例因子，使其 数值部分绝对值小于1，即： 9 × 10－28＝0.9 × 10－27 2 × 1033＝0.2 × 1034 浮点表示法 把一个数的有效数字和数的范围在计算机的一个存储单元中 分别予以表示，这种把数的范围和精度分别表示的方法，数的小 数点位置随比例因子的不同而在一定范围内自由浮动。

任意一个十进制数 Ｎ 可以写成 N = 10E×M 同样，在计算机中一个任意进制数 Ｎ 可以写成
比例因子的指数，称为浮 点数的指数，是一个整数 尾数，是一个纯 小数

(2.3)

Ｎ＝Ｒe ×Ｍ
比例因子的基数，对于二进计 数值的机器是一个常数，一般 规定Ｒ 为2，8或16。

(2.4)

Ｍ ：尾数，是一个纯小数。
e ：比例因子的指数，称为浮点数的指数，是一个整数。 R ：比例因子的基数，对于二进计数值的机器是一个常数，基 数R是设计者约定的，用隐含方法表示。一般规定Ｒ 为2，8或16 。

机器浮点数由阶码和尾数及其符号位组成 尾数(M)：用定点小数表示，给出有效数字的位数决定 了浮点数的表示精度； 阶码(E)：表示指数，用整数形式表示，指明小数点在数 据中的位置，决定了浮点数的表示范围。 比例因子(R) ，不表示，默认值，一般为2,8,16。 问题：在计算机中各个部分分别占据多少位？ °早期的计算机，各自定义自己的浮点数格式 问题：浮点数表示不统一会带来什么问题？

“Father” of the IEEE 754 standard
直到80年代初，各个机器内部的浮点数表示格式还没有统一 因而相互不兼容，机器之间传送数据时，带来麻烦 1970年代后期, IEEE成立委员会着手制定浮点数标准 1985年完成浮点数标准IEEE754的制定

This standard was primarily the work of one person, UC Berkeley math professor William Kahan.

现在所有计算机都采用IEEE754来表示浮 点数 www.cs.berkeley.edu/~wkahan/ ieee754status/754story.html

Prof. William Kahan

3. IEEE754标准浮点数的表示方法
IEEE（电气和电子工程师协会）754 标准，32位浮点数和64位浮 点数的标准格式为
浮点数的符号位(1 位)， 0表示正数，1表示负数 尾数(23位)，用小 数表示，小数点放 在尾数域的最前面

阶码(8 位),阶符采用隐含方式， 即采用移码方式来表示正负指 数（移码都是正数形式不需要 阶符）

移码：IEEE745标准的32位浮点数，将浮点数的指数真值e 加 上一个固定的偏移值127(01111111)变为阶码E，即

Ｅ＝e＋127.
移码方法对两个指数大小的比较和对阶操作都比较方便， 因为阶码域值大者其指数值也大，即移码的顺序与真值相同。 IEEE754 标准中，一个规格化的32位浮点数ｘ的真值可表示为 ｘ＝(－1)s×(1.Ｍ)×2Ｅ－127 e＝Ｅ－127 (2.5)

一个规格化的64位浮点数ｘ的真值为 ｘ＝(－1)s×(1.Ｍ)×2Ｅ－1023 e＝Ｅ－1023 同一个浮点数的表示方法不是唯一的,如: (IEEE规格化表示) (1.75)10=1.11×20 (非规格化表示) =0.111×21 =0.0111×22 =0.00111×23

(2.6)

为提高数据的表示精度，当尾数的值不为 0 时，尾数域的 最高有效位应为1,否则以修改阶码同时左右移小数点的办法， 使其变成这一表示形式，这称为浮点数的规格化表示。 因为尾数的最高位总为1，所以这一位不需要存储而默认 是存在。

注意
当阶码E 为全0（00000000）且尾数M 也为全0时，表示的 真值x 为零，结合符号位S 为0或1，有正零和负零之分。
S 00… … 0 00… … … 0

当阶码E 为全1（1111,1111即255）且尾数M 为全0（0） 时，表示的浮点数 为无穷大，结合符号位S 为0或1，也有+∞ 和-∞之分。
S 11… … 1 00… … … 0

32位浮点数表示中，要除去E 用0000,0000和1111,1111(255)10表 示零和无穷大的特殊情况，所以 E 的范围变为1(0000,0001)到 254(1111.1110)。 因此真正的指数值e 表示范围为－126(1－127)到＋127（254 －127）。 1－127
254－127 11111110－1111111 00000001－1111111

因此32位浮点数表示的绝对值的范围约为10-38~1038。 而32位定点小数表示范围 －4294967296 ≤ x≤ 4294967296（即约－210 ≤ x≤ 210） 浮点数所表示的范围远比定点数大。 用定点表示还是浮点,要根据计算机的使用条件来确定。 一般在高档微机以上的计算机中同时采用定点、浮点表 示,由使用者进行选择,而单片机中多采用定点表示。

解释

? 全0阶码全0尾数： ＋ 0/ － 0 ? 全0阶码非0尾数：非规格化数 ? 全1阶码全0尾数：＋ ∞ /－∞ ? 全1阶码非0尾数：NaN(Not a number) ? 阶码非全0且非全1：规格化非0数

[例1] 若浮点数ｘ的754标准存储格式为(41360000)16，求其浮 点数的十进制数值。 [解:] 将十六进制数展开后，可得二进制数格式为

指数e＝阶码－127＝10000010－01111111＝00000011=(3)10 包括隐藏位1的尾数1.M＝1.011 0110 0000 0000 0000 0000＝ 1.011011 于是有 ｘ＝(－1)s×1.M×2e ＝＋(1.011011)×23＝＋1011.011 ＝(11.375)10

[例2] 将(20.59375)10转换成754标准的32位浮点数的二进制存 储格式。 [解:] 首先分别将整数和分数部分转换成二进制数： 20.59375＝10100.10011 然后移动小数点，使其在第1，2位之间 10100.10011＝1.010010011×24 于是得到： S＝0， E＝4＋127＝131＝10000011，M＝010010011 最后得到32位浮点数的二进制存储格式为： 0100 0001 1010 0100 1100 0000 0000 0000＝(41A4C000)16 S E M e＝4

练习：
（1）将5/32及－4120表示成IEEE754单精 度浮点数格式，并用十六进制书写。 （2）将十六进制的IEEE754单精度浮点数 42E48000转换成十进制数。

例 将5/32及－4120表示成IEEE754单精度浮点数格式，并用十六 进制书写。 解： （1）（5/32）10=(0.00101)2=1.01× 2－3，按照IEEE754标准单精度 浮点数的规定，因为5/32>0,所以符号为S=0。 因为尾数值为1.M，现在1.M＝1.01，所以去掉隐含的1，得 到尾数部分机器数M=01000… 00 因为阶码值为指数值加上127，所以阶码值为 E=(－3)＋127=124=(01111100)2 所以，单精度浮点数机器数表示 0 011,1110,0 010,0000,0000,0000,0000,0000

十六进制为3E200000H

(2) (－4120)10＝(－1000000011000)2＝－1.000000011× 212 S=1 M=000000011… … 00 E=12+127=139=(10001011)2 －4120的IEEE754单精度浮点机器数表示形式为 1 100,0101,1 000,0000,1100,0000,0000,0000 写成十六进制数形式为C580C000H

例 将十六进制的IEEE754单精度浮点数42E48000转换成十进制 数。 解 (42E48000)16=(0100 0010 1110 0100 1000 0000 0000 0000)2 按照IEEE754标准可以写成 0 10000101 11001001000000000000000 可以得出S=0, E=(10000101)2=(133)10 M=(0.11001001000000000000000)2＝(0.78515625)10 N=(－1)0 × (1+0.78515625) × 2133－127＝1.78515625× 26＝114.25

[例5]设机器字长16位,定点表示,尾数15位,数符1位,问： (1)定点原码整数表示时,最大正数是多少?最小负数是多少? (2)定点原码小数表示时,最大正数是多少?最小负数是多少? [解:] (1)定点原码整数表示
0 111 111 111 111 111

最大正数值＝(215－1)10＝(＋32767)10 最小负数值＝－(215－1)10＝(－32767)10
1 111 111 111 111 111

(2)定点原码小数表示 15个1 最大正数值＝(1－2－15)10＝(＋0.111...11)2 最小负数值＝－(1－2－15)10＝(－0.111..11)2

[例6]假设由S,E,M三个域组成的一个32位二进制字所表示的非规格化 浮点数ｘ,真值表示为： ｘ＝(－1)s×(1.M)×2E－128 其中数符S为1位，阶码E为8位，尾数M为23位。请问：x所表示的最大 正数、最小正数、最大负数、最小负数是多少？ [解:] 11 111 111 111 111 111 111 111 111 111 11 (1)最大正数 0

ｘ＝[1＋(1－2-23)]×2127
(2)最小正数 0 (3)最小负数 1 (4)最大负数 1
00 000 000 000 000 000 000 000 000 000 00

ｘ＝1.0×2－128
11 111 111 111 111 111 111 111 111 111 11

ｘ＝－[1＋(1－2－23)]×2127
00 000 000 000 000 000 000 000 000 000 00

ｘ＝－1.0×2－128

浮点数的溢出

。

机器浮点数表示 当机器浮点数值大于最大正数A值，或小于最小负数B值时 ，称为上溢，这两种情况意味着阶码运算值超出了它所表示的范 围，机器必须做中断处理。 当机器浮点数值小于最小正数a值，或大于最大负数b值时， 称为下溢。下溢不是一个严重问题，通常看作为机器零。

例：float类型（即IEEE754单精度浮点数格式）能
表示的最大正整数是（） 126 103 127 104 B. 2 －2 A. 2 －2 127 103 128 104 C. 2 －2 D. √ －2 2
M=111,1111,1111,1111,1111,1111 1.M=1+(1－2 E=11111110 e=254－127=127 [1+(1－2
－23 －23

)

)] ×2

127

=2 －2

128

104

? int 转化为 float

不会发生溢出，可能有数据被舍入 ? 从int, float转化为double double的有效位更多，能保留精确值 ? double转化为float float表示范围更小，有可能溢出，也有可能舍入 ? float或double转int时 int没有小数部分，数据朝0截断。1.9999被转化为1，-1.9999转 化为-1

37秒 5亿美元通信卫星 控制惯性导航系统的计算机向控制引擎喷嘴的计算机发 送一个无效数据。不是飞行控制信息，是一个异常诊断位模 式数据，将一个64位浮点数转化为16位定点带符号整数时产 生溢出，溢出的值是火箭的水平速速度，比Ariana 4 速度超 过5倍，设计Ariana 4 时认为速度不会超过16位整数，设计 Ariana 5 时没检查直接用原来的设计。

例： 假定变量i，f，d数据类型分别为int, float, double(int用 补码表示，float和double用IEEE754单精度和双精度浮点数 据格式表示)，已知i=785，f=1.5678e3，d=1.5e100，若在32 位机器中执行下列关系表达式，则结果为真的是（） (I) i＝＝(int)(float)i (II) f＝＝(float)(int)f (III) f＝＝(float)(double)f (IV) (d＋f)－d＝＝f A. 仅I和II C. 仅II和III B. 仅I和III D. 仅III和IV

√

例：float型数据通常用IEEE 754单精度浮点数格式
表示。若编译器将float型变量x分配在一个32位浮点 寄存器FR1中，且x = －8.25，则FR1的内容是（） A. C104 0000H B. C242 0000H √ C. C184 0000H D. C1C2 0000H
－8.25= －1000.01= －1.00001×2 M=00001000000000000000000 E=3+127=130=10000010 1100,0001,0000,0100,0000,0000,0000,0000 C1040000H
3

例：某数采用IEEE单精度浮点数格式表示为 C640 0000H,则该数的值是( A. √ －1.5×2 C.
13 13

)
12 12

B. －1.5×2

－0.5×2

D. －0.5×2

例： float型整数据常用IEEE754单精度浮点格式表示，假设 两个float型变量x和y分别在32为寄存器f1和f2中，若（f1） =CC900000H, （f2）=B0C00000H,则x和y之间的关系为： A x<y且符号相同 √ x>y且符号相同 C B x<y且符号不同 D x>y且符号不同

2.6 浮点运算方法和浮点运算器
2.6.1 浮点加、减法运算 2.6.2 浮点乘、除法运算 2.6.3 浮点运算流水线 2.6.4 浮点运算器实例

2.6.1 浮点加法、减法运算
例：5.6× 102＋3.7× 105＝？ 解： 5.6× 102＝0.0056 ×105。 5.6× 102＋3.7× 105＝ 0.0056 ×105 ＋3.7× 105 ＝（ 0.0056 ＋3.7 ） × 105 ＝3.7056 × 105 11011.011 × 23 ＋1.01111× 28 ＝? 11011.011 × 23 ＋1.01111× 28 ＝ 11011.011 × 23 ＋101111× 23 ＝ (11011.011 ＋101111) × 23 ＝ 1001010.011 × 23

2.6.1 浮点加法、减法运算
设有两个浮点数ｘ和ｙ,它们分别为 ｘ＝2Eｘ・Mｘ ｙ＝2Eｙ・Mｙ 其中EX和EY分别为数ｘ和ｙ的阶码,MX和MY为数ｘ和ｙ的尾 两浮点数进行加法和减法的运算规则是 z =ｘ±ｙ＝(Mｘ2Eｘ－Eｙ±Mｙ)2Eｙ， Eｘ<＝Eｙ (2.39)

数。

完成浮点加减运算的操作过程大体分为四步： 1. 0 操作数的检查； 2. 比较阶码大小并完成对阶； 3. 尾数进行加或减运算； 4. 结果规格化并进行舍入处理。

(1)

0 操作数检查

如果判知两个操作数ｘ或ｙ中有一个数为0,即可得知运算结 果而没有必要再进行后续的一系列操作以节省运算时间。 (2) 比较阶码大小并完成对阶

两浮点数进行加减,首先要看两数的阶码是否相同。若二数 阶码相同, 就可以进行尾数的加减运算。反之,若二数阶码不同, 必须使二数阶码相同,这个过程叫作对阶。 要对阶,首先应求出两数阶码Eｘ和Eｙ之差,即 △E ＝ Eｘ－Eｙ 若△E＝0,表示两数阶码相等,即Eｘ＝Eｙ；若△E<0,表示 Eｘ<Eｙ；若△E>0,表示Eｘ>Eｙ。

当Eｘ≠Eｙ 时,要通过尾数的移动以改变Eｘ或Eｙ,使之相 等。 原则上,既可以通过Mｘ移位以改变Eｘ来达到Eｘ＝Eｙ,也 可以通过Mｙ移位以改变Eｙ来实现Eｘ＝Eｙ。 尾数左移会引起最高有效位的丢失,造成很大误差。尾数右移 虽引起最低有效位的丢失,但造成误差较小。 对阶操作规定使尾数右移,尾数右移后阶码作相应增加,浮点 数值保持不变。显然,一个增加后的阶码与另一个阶码相等,增加 的阶码的一定是小阶。 因此在对阶时,总是使小阶向大阶看齐,即小阶的尾数向右移 位(相当于小数点左移）每右移一位,其阶码加1,直到两数的阶码 相等为止,右移的位数等于阶差△E。

(3) 尾数求和运算 对阶结束后,即可进行尾数的求和运算。 (4) 结果规格化 1/2≤OMO＜1 假设尾数运算采用双符号位。 ⑴. 尾数求和结果的绝对值大于1(即溢出符号位为01或10), 叫做向左破坏了规格化。 向左破坏规格化时，必须进行向右规格化处理（也称右规）。 右规时，需将尾数向右移位，每移一位，阶码加1，以保证浮点 数大小不变。一直移位到满足规格化要求为止。

⑵.

尾数运算结果的绝对值如果小于1/2,叫做向右破坏了规格化。

①尾数用原码来表示，[S]原＝sf・ s1s2…sn。如果尾数未发生 溢出，但s1＝0，则向右破坏规格化。 ②尾数用补码来表示，[S]补＝sf・ s1s2…sn。如果尾数未发生 溢出，但sf  s1＝0，即sf 和 s1相同，则向右破坏规格化。 向右破坏规格化时，必须进行向左规格化处理（也称左规）。 右规时，需将尾数向左移位，每移一位，阶码减1，以保证浮点 数大小不变。一直移位到满足规格化要求为止。

(5) 舍入处理 在对阶或向右规格化时,尾数要向右移位,这样,被右移的尾数 的低位部分会被丢掉,从而造成一定误差,因此要进行舍入处理。 简单的舍入方法有两种：一种是"0舍1入"法,即如果右移时被 丢掉数位的最高位为0则舍去,为1则将尾数的末位加"1"。 这样做有可能使尾数溢出，此时需再做一次右规。 1.1111111(1) 10.0000000=1.0000000×21 另一种是"恒置一"法,即只要数位被移掉,就在尾数的末尾恒置 "1"。

在IEEE754标准中,舍入处理提供了四种可选方法： 就近舍入 类似“四舍五入”。例如, 多余位数字是10010,其 值超过规定的最低有效位值的一半,故最低有效位应增1。 若多余的5位是01111,则简单的截尾即可。 若多余的5位10000：如果最低有效位现为0,则截尾；如果最 低有效位现为1,则向上进一位使其变为 0。 朝0舍入 即朝数轴原点方向舍入,就是简单的截尾。 无论尾数是正数还是负数,截尾都使取值的绝对值比原值的 绝对值小。这种方法容易导致误差积累。 朝＋∞舍入 对正数来说,只要多余位不全为0则向最低有效位 进1;对负数来说则是简单的截尾。 朝－∞舍入 处理方法正好与 朝＋∞舍入情况相反。对正数 来说,只要多余位不全为0则简单截尾;对负数来说,向最低有效位 进1。

(6) 浮点数的溢出 下图表示了浮点机器数在数轴上的分布情况。

。

机器浮点数表示 当机器浮点数值大于最大正数A值，或小于最小负数B值时 ，称为上溢，这两种情况意味着阶码运算值超出了它所表示的范 围，机器必须做中断处理。 当机器浮点数值小于最小正数a值，或大于最大负数b值时， 称为下溢。下溢不是一个严重问题，通常看作为机器零。

浮点数的溢出是以其阶码溢出表现出来的。在加\减运算过程 中要检查是否产生了溢出：若阶码正常,加(减)运算正常结束；若阶 码溢出,则要进行相应处理。另外对尾数的溢出也需要处理。 阶码上溢 超过了阶码可能表示的最大值的正指数值,一般将其 认为是＋∞和－∞。 阶码下溢 超过了阶码可能表示的最小值的负指数值,一般将其 认为是0。 尾数上溢 两个同符号尾数相加产生了最高位向上的进位,将尾 数右移,阶码增1来重新对齐。 尾数下溢 在将尾数右移时,尾数的最低有效位从尾数域右端流 出,要进行舍入处理。

[例25] 设ｘ＝2010×0.11011011,ｙ＝2100×(－0.10101100),求 ｘ＋ｙ。 [解:] 为了便于直观理解,假设两数均以补码表示,阶码采用双符 号位,尾数采用单符号位,则它们的浮点表示分别为 [ｘ]浮＝00 010, 0.11011011 1.01010100 [ｙ]浮＝00 100, <1> 求阶差并对阶 △E＝Eｘ－Eｙ＝[Eｘ]补＋[－Eｙ]补＝00 010＋11 100＝11 110 即△E为－2,ｘ的阶码小,应使Mｘ右移两位,Eｘ加2, [ｘ]浮＝00 100,0.00110110(11) 其中(11)表示Mｘ右移2位后移出的最低两位数。

<2> 尾数求和 0. 0 0 1 1 0 1 1 0 (11) ＋ 1. 0 1 0 1 0 1 0 0 ──────────── 1. 1 0 0 0 1 0 1 0 (11) <3>规格化处理 尾数运算结果的符号位与最高数值位同值,应执行左规处理, 结果为1.00010101(10),阶码为 00 011。 <4>舍入处理 采用0舍1入法处理,则有 1. 0 0 0 1 0 1 0 1 ＋ 1 ──────────────── 1. 0 0 0 1 0 1 1 0 <5>判溢出 阶码符号位为00,不溢出,故得最终结果为 ｘ＋ｙ＝2011×(－0.11101010)

2.6.2 浮点乘法、除法运算
1.浮点乘法、除法运算规则 设有两个浮点数ｘ和ｙ： ｘ＝2Eｘ・Mｘ ｙ＝2Eｙ・Mｙ 浮点乘法运算的规则是 (2.40) 即乘积的尾数是相乘两数的尾数之积,乘积的阶码是相乘两 数的阶码之和。当然,这里也有规格化与舍入等步骤。 浮点除法运算的规则是

ｘ×ｙ＝2(Eｘ＋Eｙ)・(Mｘ×Mｙ)

ｘ÷ｙ＝2(Eｘ－Eｙ)・(Mｘ÷Mｙ)

(2.41)

商的尾数是相除两数的尾数之商,商的阶码是相除两数的阶码 之差。也有规格化和舍入等步骤。

2.浮点乘、除法运算步骤 浮点数的乘除运算大体分为四步： 第一步,0 操作数检查； 第二步,阶码加/减操作； 第三步,尾数乘/除操作； 第四步,结果规格化及舍入处理。 (1) 浮点数的阶码运算 对阶码的运算有＋1、－1、两阶码求和、两阶码求差四种, 运算时还必须检查结果是否溢出。 阶码通常用补码或移码表示。 补码运算规则和判定溢出的方法,前面已经讲过。 移码的运算规则和判定溢出的方法:

移码的定义为 [ｘ]移＝2n＋ｘ 2n＞ｘ≥－2n 按此定义,则有 [ｘ]移＋[ｙ]移＝2n＋ｘ＋2n＋ｙ ＝2n＋(2n＋(ｘ＋ｙ)) ＝2n＋[ｘ＋ｙ]移 即直接用移码实现求阶码之和时,结果的最高位多加了个1, 要得到正确的移码形式结果,必须对结果的符号再执行一次求反 。 混合使用移码和补码时,考虑到移码和补码的关系：数值位 完全相同,而符号位正好完全相反。 [ｙ]补的定义为 [ｙ]补＝2n＋1＋ｙ

则求阶码和用如下方式完成： [ｘ]移＋[ｙ]补＝2n＋ｘ＋2n＋1＋ｙ ＝2n＋1＋(2n＋(ｘ＋ｙ)) ＝2n＋1＋[ｘ＋ｙ]移 即 [ｘ＋ｙ]移＝[ｘ]移＋[ｙ]补 同理 [ｘ－ｙ]移＝[ｘ]移＋[－ｙ]补 (2.43) (mod 2n＋1) (2.42)

上二式表明执行阶码加减时,对加数或减数 ｙ来说,应送移 码符号位正常值的反码。

移码溢出的判断： 双符号位,并规定移码的第二个符号位,即最高符号位恒用 0 表 示,则溢出条件是最高符号位为1。 当两位符号位为 10时,表明上溢,为11时,表明下溢。 当最高符号位为0时,表明没有溢出； 两位符号位为01时,结果为正；为 00 时,结果为负。 [例26] ｘ＝＋011,ｙ＝＋110,求[ｘ＋ｙ]移 和 [ｘ－ｙ]移,并判断是 否溢出。 [解:] [ｘ]移＝01 011, [ｙ]补＝00 110, [－ｙ]补＝11 010 [ｘ＋ｙ]移＝[ｘ]移＋[ｙ]补＝10 001, 结果上溢。 [ｘ－ｙ]移＝[ｘ]移＋[－ｙ]补＝00 101, 结果正确,为－3。

(2) 尾数处理 浮点加减法对结果的规格化及舍入处理适用浮点乘除法。 第一种方法:截断处理，即丢掉正常尾数最低位之后的全部数值 。 优点是处理简单,缺点是影响结果的精度。 第二种办法:舍入处理，即运算过程中保留右移中移出的若干高 位的值,最后再按某种规则用这些位上的值修正尾数。 当尾数用原码表示时,舍入规则比较简单。 最简便的方法：只要尾数的最低位为1,或移出的几位中有为1的 数值位,就是最低位的值为1。 另一种是0舍1入法,即当丢失的最高位的值为1时,把这个1加到最 低数值位上进行修正,否则舍去丢失的的各位的值。 这样处理时,舍入效果对正数负数相同,入将使数的绝对值变大,舍 则使数的绝对值变小。

当尾数是用补码表示时,所用的舍入规则,应该与用原码表 示时产生相同的处理效果。 具体规则是： 当丢失的各位均为0时,不必舍入操作； 当丢失的最高位为0 时,以下各位不全为0 时,或者丢失的 最高位为1,以下各位均为0时,则舍去丢失位上的值； 当丢失的最高位为1,以下各位不全为0 时,则执行在尾数 最低位入1的修正操作。

[例27] 设[ｘ1]补＝11.01100000,[ｘ2]补＝11.01100001, [ｘ3]补＝11.01101000,[ｘ4]补＝11.01111001,求执行只保留小数点 后4位有效数字的舍入操作值。 [解:] 执行舍入操作后,其结果值分别为 [ｘ1]补＝11.0110 (不舍不入) [ｘ2]补＝11.0110 (舍) [ｘ3]补＝11.0110 (舍) [ｘ4]补＝11.1000 (入)

[例28] 设有浮点数ｘ＝2－5×0.0110011,ｙ＝23×(－0.1110010),阶码 用4位移码表示,尾数 (含符号位)用8位补码表示。 求[ｘ×ｙ]浮。 要求用补码完成尾数乘法运算,运算结果尾数保留高8位(含符 号位),并用尾数低位字长值处理舍入操作。 [解:] 移码采用双符号位,尾数补码采用单符号位,则有 [Mｘ]补＝0.0110011, [Mｙ]补＝1.0001110, [Eｙ]移＝01 011, [Eｙ]补＝00 011, [Eｘ]移＝00 011, [ｘ]浮＝00 011, 0.0110011, [ｙ]浮＝01 011, 1.0001110 (1) 求阶码和 [Eｘ＋Eｙ]移＝[Eｘ]移＋[Eｙ]补＝00 011＋00 011＝00 110, 值为移码形式－2。 (2) 尾数乘法运算 可采用补码阵列乘法器实现,即有 [Mｘ]补×[Mｙ]补＝[0.0110011]补×[1.0001110]补 ＝[1.1010010,1001010]补

(3) 规格化处理 乘积的尾数符号位与最高数值位符号相同,不是规格化的 数,需要左规,阶码变为00 101(―3), 尾数变为 1.0100101,0010100。 (4) 舍入处理 尾数为负数,取尾数高位字长，按舍入规则,舍去低位字长 ，故尾数为1.0100101 。 最终相乘结果为 [ｘ×ｙ]浮＝00 101,1.0100101 其真值为 ｘ×ｙ＝2－3×(－0.1011011)

2.6.3 浮点运算流水线
1.流水线原理 计算机的流水处理过程同工厂中的流水装配线类似。为了 实现流水,首先必须把输入的任务分割为一系列的子任务,使各子 任务能在流水线的各个阶段并发地执行。 将任务连续不断地输入流水线,从而实现了子任务的并行。 因此流水处理大幅度地改善了计算机的系统性能,是在计算机上 实现时间并行性的一种非常经济的方法。 在流水线中,原则上要求各个阶段的处理时间都相同。若某 一阶段的处理时间较长,势必造成其他阶段的空转等待。 因此对子任务的划分,是决定流水线性能的一个关键因素,它 取决于操作部分的效率、所期望的处理速度,以及成本价格等等 。

假定作业 T 被分成 k 个子任务,可表达为 T＝{T1,T2,・・・,Tk} 各个子任务之间有一定的优先关系：若i<j,则必须在 Ti 完成 以后,Tj才能开始工作。具有这种线性优先关系的流水线称为线 性流水线。线性流水线处理的硬件基本结构如图所示

图中,处理一个子任务的过程为过程段(Si)。 线性流水线由一系列串联的过程段组成,各个过程之间设有 高速的缓冲寄存器(L),以暂时保存上一过程子任务处理的结果。 在一个统一的时钟(C)控制下,数据从一个过程段流向相邻的 过程段。 设过程段 Si所需的时间为τi,缓冲寄存器的延时为τl,线性 流水线的时钟周期定义为 τ＝max{τi}＋τl＝τm＋τl 故流水线处理的频率为 f＝1/τ。 (2.44)

在流水线处理中,当任务饱满时,任务源源不断的输入流水线, 不论有多少级过程段,每隔一个时钟周期都能输出一个任务。 从理论上说,一个具有k 级过程段的流水线处理 n 个任务需 要的时钟周期数为 Tk＝k＋(n－1) (2.45)

其中k个时钟周期用于处理第一个任务。k个周期后,流水线 被装满,剩余的n－1个任务只需n－1个周期就完成了。 如果用非流水线的硬件来处理这n个任务,时间上只能串行进 行,则所需时钟周期数为 (2.46) TL＝n・k

我们将TL和Tk的比值定义为k级线性流水线的加速比： n・k . TL ＝ Ck＝ k＋(n－1) Tk (2.47)

当 n>>k 时, Ck－>k 。这就是说,理论上k级线性流水线 处理几乎可以提高k倍速度。 但实际上由于存储器冲突、数据相关,这个理想的加速 比不一定能达到。 2.流水线浮点加法器 从图2.16可以看出，浮点数加减法由0操作数检查、对阶操 作、尾数操作、结果规格化及舍入处理共4步完成，因此流水 线浮点加法器可由4个过程段组成。 图2.18仅示出了除0操作数检查之外的3段流水线浮点加法 器框图。

在浮点数原码运算时, 判定结果为规 格化数的条件是 。 A. 阶的符号位与尾数的符号位不同 B. 尾数的符号位与最高数值位相同 C. 尾数的符号位与最高数值位不同 D. 尾数的最高数值位为1 若浮点数用补码表示，则判断运算结果是否为规格化数的方法 是 A．阶符与数符相同为规格化数 B. 阶符与数符相异为规格化数 C．数符与尾数小数点后第一位数字相异为规格化数 D．数符与尾数小数点后第一位数字相同为规格化数

例：浮点数加减运算过程一般包括对阶、尾数运算、规格化、 舍入和判溢出等步骤。设浮点数的阶码和尾数均采用补码表示， 且位数分别为5位和7位（均含2位符号位）。若有两个数 7 5 X=2 ×29/32，Y=2 ×5/8，则用浮点加法计算X+Y的最终结果是 （） A．00111 1100010 B. 00111 0100010 C．01000 0010001 D. 发生溢出
7

X=0.11101×2 00 111 Y=0.101×2
5

00 11101 00 10100 00 00101

00 101

小阶码向大阶码看齐 Y:00 111

00 11101+00 00101=01 00010(溢出)，但阶码已经最大

例：下列有关浮点数加减运算的叙述中，正确的是(
Ⅰ.对阶操作不会引起阶码的上溢或下溢 Ⅱ.右规和尾数舍入都可能引起阶码的上溢 Ⅲ.左规时可能引起阶码的下溢 Ⅳ.尾数溢出时结果不一定溢出 A. 仅Ⅱ、Ⅲ C. 仅Ⅰ、Ⅲ、Ⅳ B. 仅Ⅰ、Ⅱ、Ⅳ D. Ⅰ、Ⅱ、Ⅲ、Ⅳ

)

√

 